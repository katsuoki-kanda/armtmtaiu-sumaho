<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>あいうえお・ハンドゲーム (UI・円・リング拡大版)</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <style>
        body { 
            margin: 0; 
            background-color: #000; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            width: 100vw;
            overflow: hidden; 
            font-family: sans-serif; 
            position: fixed; 
            touch-action: none;
        }
        #container { 
            position: relative; 
            width: 100%; 
            height: 100%; 
        }
        canvas { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            object-fit: cover; 
            transform: scaleX(-1); 
        }
        video { display: none; }
        
        /* UIレイヤー: 1.2倍に拡大 (30px -> 36px) */
        .overlay-text { 
            position: absolute; 
            color: #0f0; 
            font-size: 36px; 
            text-shadow: 2px 2px 5px #000; 
            font-weight: bold; 
            z-index: 10;
            padding: 15px;
            pointer-events: none;
        }
        #score-board { top: env(safe-area-inset-top, 20px); left: 10px; }
        #timer-board { top: env(safe-area-inset-top, 20px); right: 10px; color: #fff; }

        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); color: white; display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 100; text-align: center;
        }
        button {
            padding: 20px 40px; font-size: 26px; font-weight: bold; border-radius: 15px;
            border: none; background: #2ecc71; color: white; cursor: pointer; margin-top: 20px;
        }
    </style>
</head>
<body>

<div id="container">
    <video id="input_video" playsinline></video>
    <canvas id="output_canvas"></canvas>
    
    <div id="score-board" class="overlay-text">Score: 0</div>
    <div id="timer-board" class="overlay-text">Time: 40</div>

    <div id="overlay">
        <h2>ひらがなハンドゲーム</h2>
        <p style="font-size: 20px;">画面に出てくる「あいうえお」の順に<br>タッチしてね！</p>
        <button id="startButton">ゲームをはじめる</button>
    </div>
</div>

<script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const overlay = document.getElementById('overlay');
    const startBtn = document.getElementById('startButton');
    const scoreElement = document.getElementById('score-board');
    const timerElement = document.getElementById('timer-board');

    let audioCtx;
    const synth = window.speechSynthesis;
    
    function initAudio() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();
    }

    function playBeep() {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.frequency.setValueAtTime(900, audioCtx.currentTime);
        osc.start();
        gain.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.1);
        osc.stop(audioCtx.currentTime + 0.1);
    }

    function speak(text) {
        const utter = new SpeechSynthesisUtterance(text);
        utter.lang = 'ja-JP';
        synth.speak(utter);
    }

    const hiraganaGroups = [
        ["あ", "い", "う", "え", "お", "か", "き", "く", "け", "こ"],
        ["さ", "し", "す", "せ", "そ", "た", "ち", "つ", "て", "と"],
        ["な", "に", "ぬ", "ね", "の", "は", "ひ", "ふ", "へ", "ほ"],
        ["ま", "み", "む", "め", "も", "ら", "り", "る", "れ", "ろ"]
    ];
    
    let currentGroupIndex = 0; 
    let score = 0;
    let gameStarted = false;
    let cameraReady = false; 
    let startTime = 0;
    let nextStartEnabledTime = 0;
    const gameDuration = 40;
    
    let circleRadius = 0; 
    let circles = [];
    let targetCount = 1;

    function updateUnitSizes() {
        const unit = Math.min(canvasElement.width, canvasElement.height);
        // 赤丸の直径を1.2倍に拡大 (元: 0.08 -> 0.096)
        circleRadius = unit * 0.096;
    }

    function generateCircles() {
        circles = [];
        targetCount = 1;
        const currentList = hiraganaGroups[currentGroupIndex];
        const shuffledList = [...currentList].sort(() => Math.random() - 0.5);
        
        const videoW = canvasElement.width;
        const videoH = canvasElement.height;
        const screenW = window.innerWidth;
        const screenH = window.innerHeight;
        const videoAspect = videoW / videoH;
        const screenAspect = screenW / screenH;
        
        let visibleW = videoW;
        let visibleH = videoH;
        let offsetX = 0;
        let offsetY = 0;

        if (videoAspect > screenAspect) {
            visibleW = videoH * screenAspect;
            offsetX = (videoW - visibleW) / 2;
        } else {
            visibleH = videoW / screenAspect;
            offsetY = (videoH - visibleH) / 2;
        }

        const cols = 2;
        const rows = 5;
        const safePadding = circleRadius * 1.5;
        const topMargin = 150 + offsetY; 
        const bottomMargin = 80 + offsetY + (circleRadius * 2); 
        
        const cellW = (visibleW - safePadding * 2) / cols;
        const cellH = (visibleH - topMargin - bottomMargin) / rows;

        let gridPositions = [];
        for(let r=0; r<rows; r++) {
            for(let c=0; c<cols; c++) {
                gridPositions.push({r, c});
            }
        }
        gridPositions.sort(() => Math.random() - 0.5);

        for (let i = 0; i < 10; i++) {
            const pos = gridPositions[i];
            const x = offsetX + safePadding + (pos.c * cellW) + (Math.random() * (cellW - circleRadius * 2)) + circleRadius;
            const y = topMargin + (pos.r * cellH) + (Math.random() * (cellH - circleRadius * 2)) + circleRadius;
            circles.push({ x: x, y: y, value: shuffledList[i], hit: false });
        }
    }

    function onResults(results) {
        cameraReady = true; 
        const currentTime = Date.now();

        if (canvasElement.width !== results.image.width || canvasElement.height !== results.image.height) {
            canvasElement.width = results.image.width;
            canvasElement.height = results.image.height;
            updateUnitSizes();
        }

        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

        let timeLeft = 0;
        if (gameStarted) {
            timeLeft = Math.max(0, gameDuration - Math.floor((currentTime - startTime) / 1000));
            scoreElement.innerText = `Score: ${score}`;
            timerElement.innerText = `Time: ${timeLeft}`;

            if (timeLeft <= 0) {
                gameStarted = false;
                nextStartEnabledTime = currentTime + 3000;
                speak(score + "点です。終了。");
            }
        }

        let hands = [];
        if (results.poseLandmarks) {
            const lIdx = results.poseLandmarks[19]; 
            const rIdx = results.poseLandmarks[20]; 
            
            if(lIdx.visibility > 0.5) hands.push({ x: lIdx.x * canvasElement.width, y: lIdx.y * canvasElement.height });
            if(rIdx.visibility > 0.5) hands.push({ x: rIdx.x * canvasElement.width, y: rIdx.y * canvasElement.height });

            // 手の黄色リングを1.5倍に拡大 (元: 30 -> 45)
            hands.forEach(h => {
                canvasCtx.beginPath();
                canvasCtx.arc(h.x, h.y, 45, 0, 2 * Math.PI);
                canvasCtx.strokeStyle = 'yellow';
                canvasCtx.lineWidth = 8;
                canvasCtx.stroke();
            });

            if (!gameStarted && currentTime > nextStartEnabledTime) {
                if (lIdx.y < 0.2 || rIdx.y < 0.2) {
                    gameStarted = true;
                    score = 0;
                    currentGroupIndex = 0; 
                    startTime = Date.now();
                    generateCircles();
                    speak("スタート");
                }
            }
        }

        if (gameStarted) {
            let allHit = true;
            const currentList = hiraganaGroups[currentGroupIndex];

            circles.forEach(c => {
                if (!c.hit) {
                    allHit = false;
                    if (c.value === currentList[targetCount - 1]) {
                        hands.forEach(h => {
                            const dist = Math.sqrt((h.x - c.x) ** 2 + (h.y - c.y) ** 2);
                            // ヒット判定もリング拡大に合わせて少し調整 (35 -> 50)
                            if (dist < circleRadius + 50) {
                                c.hit = true;
                                score++;
                                targetCount++;
                                playBeep();
                            }
                        });
                    }
                    
                    canvasCtx.beginPath();
                    canvasCtx.arc(c.x, c.y, circleRadius, 0, 2 * Math.PI);
                    canvasCtx.fillStyle = 'red'; 
                    canvasCtx.fill();
                    canvasCtx.strokeStyle = 'white';
                    canvasCtx.lineWidth = 2;
                    canvasCtx.stroke();
                    
                    canvasCtx.save();
                    canvasCtx.translate(c.x, c.y);
                    canvasCtx.scale(-1, 1); 
                    canvasCtx.fillStyle = 'white';
                    // 文字サイズをさらに拡大 (元: 0.9 -> 1.0)
                    canvasCtx.font = `bold ${Math.floor(circleRadius * 1.0)}px Arial`;
                    canvasCtx.textAlign = "center";
                    canvasCtx.textBaseline = "middle";
                    canvasCtx.fillText(c.value, 0, 0);
                    canvasCtx.restore();
                } else {
                    canvasCtx.beginPath();
                    canvasCtx.arc(c.x, c.y, circleRadius, 0, 2 * Math.PI);
                    canvasCtx.fillStyle = 'rgba(0, 255, 0, 0.4)';
                    canvasCtx.fill();
                }
            });

            if (allHit) {
                currentGroupIndex = (currentGroupIndex + 1) % hiraganaGroups.length;
                generateCircles();
            }
        }

        // ガイド表示を1.2倍に調整 (元: 42px -> 50px)
        if (!gameStarted && cameraReady) {
            canvasCtx.save();
            canvasCtx.translate(canvasElement.width / 2, canvasElement.height / 2);
            canvasCtx.scale(-1, 1);
            canvasCtx.fillStyle = "white";
            canvasCtx.font = "bold 50px Arial";
            canvasCtx.textAlign = "center";
            if (currentTime < nextStartEnabledTime) {
                canvasCtx.fillText(`${Math.ceil((nextStartEnabledTime - currentTime) / 1000)}秒待ってね`, 0, 0);
            } else {
                canvasCtx.fillStyle = "yellow";
                canvasCtx.fillText("片手を挙げてスタート", 0, 0);
            }
            canvasCtx.restore();
        }
        canvasCtx.restore();
    }

    const pose = new Pose({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}` });
    pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    pose.onResults(onResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => { await pose.send({image: videoElement}); },
        width: 1280, height: 720,
        facingMode: 'user'
    });

    startBtn.addEventListener('click', () => {
        initAudio(); 
        overlay.style.display = 'none';
        camera.start();
        speak("カメラ起動");
    });
</script>
</body>
</html>